<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <link rel="stylesheet" href="https://cdn.simplecss.org/simple.min.css">
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/an-old-hope.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://code.jquery.com/jquery-3.7.1.min.js" defer></script>
  <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js" defer></script>
  <script src="https://cdn.jsdelivr.net/npm/benchmark@2.1.4/benchmark.min.js" defer></script>
  <script src="main.js" defer></script>
  <title>Baduk JS - Step By Step</title>
</head>

<body>
  <header>
    <h1>Baduk JS - Step By Step</h1>
    <p>Experiments in Baduk/Game of Go/Weiqi using JavaScript</p>
  </header>

  <main>
    <aside>
      <nav>
        <a href="#Introduction">Introduction</a>
        <a href="#TheVisionAhead">The Vision Ahead</a>
        <a href="#TheFirstStep">The First Step</a>
        <a href="#FloodFill">Flood Fill</a>
        <a href="#Metadata">Metadata</a>
        <a href="#Scoring">Scoring</a>
        <a href="#UnitTests">Unit Tests</a>
      </nav>
    </aside>
    <h2 id="Introduction"><a href="#Introduction">Introduction</a></h2>
    <p>This page intends to demonstrate a series of small steps that all together will reach a more distant goal.</p>
    <p>Writing a large program can be a daunting task. Even if the end goal is clearly envisioned, the steps to get
      there might be only somewhat understood in advance. Many times the path forward must be discovered one step at a
      time.</p>
    <p>I have the goal of writing a <i>reasonably</i> performing Monte Carlo Tree Search (MCTS) bot for playing the Game
      of Go. I'm going to write it all in JavaScript.</p>
    <p>In order to avoid burnout along the way, I will be dividing up the large size task into many small steps. Each of
      the sections below will focus on one of those small steps.</p>
    <p>This page is a <i>living document</i> and will be updated as I write more sections ...</p>

    <section>
      <h2 id="TheVisionAhead"><a href="#TheVisionAhead">The Vision Ahead</a></h2>
      <p>I want to pick a medium sized goal to directly plan towards.
        I know that an MCTS bot will need to enact the <i>rules of the game</i> in order to perform automated Rollouts.
        It will also need a way to score a <b>finished game</b> for counting Rollout wins and losses.</p>
      <p>The file <code>liberty_score.txt</code> contains my vision for the minimum abilities a computer would need to
        enforce the rules of Go.</p>
      <ol>
        <li><mark>Count Liberties</mark></li>
        <li><mark>Score a Finished Board</mark></li>
      </ol>

      <details>
        <summary>liberty_score.txt</summary>
        <pre><code preload-txt="liberty_score.txt"></code></pre>
      </details>

      <p>The text file is written so a human can read it. It's also carefully formatted so it can be read into a
        script and parsed into a set of Unit Tests.</p>
      <p>The next section will start on the path to loading, parsing and <i>eventually</i> executing the Unit Tests in
        this file.</p>
    </section>

    <section>
      <h2 id="TheFirstStep"><a href="#TheFirstStep">The First Step</a></h2>
      <p>Before we tackle <code>liberty_score.txt</code> let's start with something less complicated.
        The first step is reading a text file with an example position from a 5x5 board.
        It will be easier to parse because it only has a single board and has no extra headers, comments, or trailing
        whitespace.
        The overall structure of <code>board5x5.txt</code> is as simple as we can make it while still being a meaningful
        first step.
      </p>

      <pre><summary>board5x5.txt</summary><code preload-txt="board5x5.txt"></code></pre>

      <p>We can add coordinate labels for both axes while we're parsing the board.
        Let's also restore the whitespace between the columns.</p>

      <details>
        <summary>board5x5.js</summary>
        <pre><code preload-javascript="board5x5.js"></code></pre>
      </details>

      <script src="board5x5.js" defer></script>
      <div data="board5x5.txt" run="board5x5">
        <button run>Run</button> <button time>Time</button> <mark hidden></mark>
        <pre><summary>output</summary><code output></code></pre>
      </div>

    </section>

    <section>
      <h2 id="FloodFill"><a href="#FloodFill">Flood Fill</a></h2>
      <p>Now that we feel comfortable <i>parsing</i> the text board we can look ahead to processing the board for more
        details.</p>
      <p>To reach our medium goal we need to "count liberties" and "score the game". Scoring the game further relies on
        identifying "enclosed empty spots" and which stone colour they "belong to".</p>
      <ol>
        <li><mark>Count Liberties</mark>
          <ul>
            <li>Follow a chain of same-colour stones.</li>
            <li>Count all the adjacent empty spots.</li>
          </ul>
        </li>
        <li><mark>Enclosed Empty Spots</mark>
          <ul>
            <li>Follow a chain of empty spots.</li>
            <li>Identify the adjacent stone colours.</li>
          </ul>
        </li>
      </ol>
      <p>Both of these abilities rely on an even smaller ability. We need to be able to follow "chains" of
        same-type pieces on the board. I know from experience that trying to do this task by "scanning" is possible
        but very time consuming. The efficient approach here is to use Flood Fill (aka DFS, Depth First Search)</p>
      <p>The scenario in <code>flood5x5.txt</code> challenges us to handle several issues.</p>
      <ul>
        <li>Follow the chain of stones through several branching points.</li>
        <li>Avoid an infinite loop following the circular path of stones.</li>
        <li>Avoid re-counting adjacent empty spots from multiple angles.</li>
      </ul>

      <pre><summary>flood5x5.txt</summary><code preload-txt="flood5x5.txt"></code></pre>

      <p>Let's count the number stones in the black chain and the number of liberties it's touching.
        We'll also show the number of <i>visits</i> at each location of the board during our Flood Fill.</p>

      <details>
        <summary>flood5x5.js</summary>
        <pre><code preload-javascript="flood5x5.js"></code></pre>
      </details>

      <script src="flood5x5.js" defer></script>
      <div data="flood5x5.txt" run="flood5x5">
        <button run>Run</button> <button time>Time</button> <mark hidden></mark>
        <pre><summary>output</summary><code output></code></pre>
      </div>
    </section>

    <section>
      <h2 id="Metadata"><a href="#Metadata">Metadata</a></h2>
      <p>At this point we have most of the pieces we need to calculate Liberties and Score.
        However, it would be quite slow if we naively try to continue with only this.
        For example, to display Liberty Counts for the entire board, each stone would need to run Flood Fill,
        which would then visit every stone and Liberty associated with the stone's chain.
        For long chains this redunancy would be very time consuming.</p>
      <p>We need a way to identify which chain each stone belongs to.
        We can store information related to a chain as metadata once it has been calculated.
        Whenever the metadata is required it can be retrieved by the "chain id".
        This will also be of value later when we simulate entire games.
        The metadata for a chain remains unchanged until another stone is placed next to it.</p>

      <pre><summary>board5x5.txt</summary><code preload-txt="board5x5.txt"></code></pre>

      <p>Let's assign chain ids to each stone in <code>board5x5.txt</code>.
        Stones that are connected and of the same colour will share the same "chain id".
        Unconnected stones or adjacent stones of different colour need unique ids.
        The chain ids must not be re-used for other chains.
        We also won't be assigning chain ids to empty spots.</p>

      <details>
        <summary>chain5x5.js</summary>
        <pre><code preload-javascript="chain5x5.js"></code></pre>
      </details>

      <script src="chain5x5.js" defer></script>
      <div data="board5x5.txt" run="chain5x5">
        <button run>Run</button> <button time>Time</button> <mark hidden></mark>
        <pre><summary>output</summary><code output></code></pre>
      </div>
    </section>

    <section>
      <h2 id="Scoring"><a href="#Scoring">Scoring</a></h2>
      <p>The function <code>buildChains()</code> also doubles as a great way to count liberties.
        With that done the only ability we need code for now is Scoring the Game.
        Scoring is very similar to Counting Liberties with these differences:</p>
      <ul>
        <li>Follow empty spots instead of stones.</li>
        <li>Identify the <i>types</i> of adjacent stones instead of summing them up.</li>
      </ul>

      <div>
        <pre><summary>board5x5.txt</summary><code preload-txt="board5x5.txt"></code></pre>
      </div>

      <p>We'll need to scan the board for stones but not follow them,
        and follow empty spots as we find them.
        Let's only invoke DFS the first time we encounter each "chain" of empty spots.</p>

      <details>
        <summary>score5x5.js</summary>
        <pre><code preload-javascript="score5x5.js"></code></pre>
      </details>

      <script src="score5x5.js" defer></script>
      <div data="board5x5.txt" run="score5x5">
        <button run>Run</button> <button time>Time</button> <mark hidden></mark>
        <pre><summary>output</summary><code output></code></pre>
      </div>
    </section>

    <section>
      <h2 id="UnitTests"><a href="#UnitTests">Unit Tests</a></h2>
      <p>We have enough code now to solve all the unit tests in <code>liberty_score.txt</code>.
        But we still need to extract the tests from the text file and verify the outputs.</p>

      <details>
        <summary>liberty_score.txt</summary>
        <pre><code preload-txt="liberty_score.txt"></code></pre>
      </details>

      <p>Let's start by extracting the input/output boards:</p>

      <ul>
        <li><mark>Liberty Count</mark>
          <ul>
            <li>1 input board</li>
            <li>1 output board</li>
          </ul>
        </li>
        <li><mark>Enclosed Score</mark>
          <ul>
            <li>1 input board</li>
            <li>2 output boards</li>
            <li><code>key:val</code> pairs</li>
          </ul>
        </li>
      </ul>

      <details>
        <summary>extract_tests.js</summary>
        <pre><code preload-javascript="extract_tests.js"></code></pre>
      </details>

      <script src="extract_tests.js" defer></script>
      <div data="liberty_score.txt" run="extract_tests">
        <button run>Run</button> <button time>Time</button> <mark hidden></mark>
        <pre><summary>output</summary><code output></code></pre>
      </div>

      <p>We now have the full extraction of the Unit Tests.
        With tests in hand we can verify the correctness of our previous functions.</p>

      <script src="test5x5.js" defer></script>
      <div data="liberty_score.txt" run="test5x5">
        <button run>Run</button> <button time>Time</button> <mark hidden></mark>
        <pre><summary>output</summary><code output></code></pre>
      </div>

    </section>

  </main>

  <footer>
    <p>by <a href="https://lazymammal.github.io/">LazyMammal</a></p>
  </footer>
</body>

</html>