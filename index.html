<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <link rel="stylesheet" href="https://cdn.simplecss.org/simple.min.css">
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/an-old-hope.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" defer></script>
  <script src="https://code.jquery.com/jquery-3.7.1.min.js" defer></script>
  <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js" defer></script>
  <script src="https://cdn.jsdelivr.net/npm/benchmark@2.1.4/benchmark.min.js" defer></script>
  <script src="gobo.js" defer></script>
  <script src="main.js" defer></script>
  <title>Baduk JS - Step By Step</title>
</head>

<body>
  <header>
    <h1>Baduk JS - Step By Step</h1>
    <p>Experiments in Baduk/Game of Go/Weiqi using JavaScript</p>
  </header>
  <main>
    <aside>
      <nav>
        <a href="#Introduction">Introduction</a>
        <a href="#TheVisionAhead">The Vision Ahead</a>
        <a href="#TheFirstStep">The First Step</a>
        <a href="#Rules">Rules of the Game</a>
        <a href="#FloodFill">Flood Fill</a>
        <a href="#LibertyCount">Liberty Count</a>
        <a href="#Scoring">Scoring</a>
        <a href="#UnitTests">Unit Tests</a>
        <a href="#Rollouts">Rollouts</a>
      </nav>
    </aside>
    <h2 id="Introduction"><a href="#Introduction">Introduction</a></h2>
    <p>This page intends to demonstrate a series of small steps that all together will reach a more distant goal.</p>
    <p>Writing a large program can be a daunting task. Even if the end goal is clearly envisioned, the steps to get
      there might be only somewhat understood in advance. Many times the path forward must be discovered one step at a
      time.</p>
    <p>I have the goal of writing a <i>reasonably</i> performing Monte Carlo Tree Search (MCTS) bot for playing the Game
      of Go. I'm going to write it all in JavaScript.</p>
    <p>In order to avoid burnout along the way, I will be dividing up the large size task into many small steps. Each of
      the sections below will focus on one of those small steps.</p>
    <p>This page is a <i>living document</i> and will be updated as I write more sections ...</p>
    <section>
      <h2 id="TheVisionAhead"><a href="#TheVisionAhead">The Vision Ahead</a></h2>
      <p>I want to pick a medium sized goal to directly plan towards.
        I know that an MCTS bot will need to enact the <i>rules of the game</i> in order to perform automated Rollouts.
        It will also need a way to score a <b>finished game</b> for counting Rollout wins and losses.</p>
      <p>The file <code>liberty_score.txt</code> contains my vision for the minimum abilities a computer would need to
        enforce the rules of Go.</p>
      <ol>
        <li><mark>Count Liberties</mark></li>
        <li><mark>Score a Finished Board</mark></li>
      </ol>
      <details>
        <summary>liberty_score.txt</summary>
        <pre><code preload-txt="liberty_score.txt"></code></pre>
      </details>
      <p>The text file is written so a human can read it. It's also carefully formatted so it can be read into a
        script and parsed into a set of Unit Tests.</p>
      <p>The next section will start on the path to loading, parsing and <i>eventually</i> executing the Unit Tests in
        this file.</p>
    </section>
    <section>
      <h2 id="TheFirstStep"><a href="#TheFirstStep">The First Step</a></h2>
      <p>Before we tackle <code>liberty_score.txt</code> let's start with something less complicated.
        The first step is reading a text file with an example position from a 7x7 board.
        It will be easier to parse because it only has a single board and has no extra headers, comments, or trailing
        whitespace.
        The overall structure of <code>board7x7.txt</code> is as simple as we can make it while still being a meaningful
        first step.
      </p>
      <pre><summary>board7x7.txt</summary><code preload-txt="board7x7.txt"></code></pre>
      <p>We can add coordinate labels for both axes while we're parsing the board.
        Let's also restore the whitespace between the columns.</p>
      <details>
        <summary>board7x7.js</summary>
        <pre><code preload-javascript="board7x7.js"></code></pre>
      </details>
      <script src="board7x7.js" defer></script>
      <div data="board7x7.txt" run="board7x7">
        <button run>Run</button> <button time>Time</button> <mark hidden></mark>
        <pre><summary>output</summary><code output></code></pre>
      </div>
    </section>
    <section>
      <h2 id="Rules"><a href="#Rules">Rules of the Game</a></h2>
      <p>Here's a quick refresher on the rules of Go:</p>
      <ol>
        <li>Two players take alternating turns placing single stones on the board.
          Each player can only play stones of their assigned colour (black or white).
          Stones can only be played on the intersections of lines.
          Stones cannot be <i>moved</i> from one spot to another.
          There is one rule (see below) that allows the removal of stones by "capture".</li>
        <li>A liberty is <i>acquired</i> by a stone from an empty spot.
          The empty spot must be adjacent in one of the four cardinal directions (along the lines).</li>
        <li>Liberties are <i>shared</i> among same-colour stones (forming a chain).
          The sharing stones must be connected in one of the four cardinal directions (along the lines).
          By successive application of this rule, chains can be arbitrarily large and any shape overall.</li>
        <li>Liberties are <i>unique</i> locations and cannot be counted twice.
          This means a chain of stones may wrap around an empty spot, and be adjacent to it, on up to four sides.
          However, that empty spot still only <i>counts</i> as one liberty for the chain.</li>
        <li>A stone (or chain of stones) must have at least one liberty.
          If a stone or chain has zero liberties it must be removed from the board.
          In the event of capture, all connected stones in the chain are removed at once.
          A board arrangement left with stones having zero liberties is invalid.</li>
        <li>Stones of different colours cannot share liberties.
          In fact, an important tactic of Go is playing upon the last liberty of an opponent chain.
          The action of <i>taking</i> the last liberty results in the capture of the starved chain.</li>
        <li>The capture rule is handled prior to the final assessment of liberties of a newly placed stone.
          This means a player may legally place a stone in a spot <i>with no apparent liberties</i>, if by
          <i>capture</i> or <i>liberty sharing</i> the new stone will end up with at least one liberty.
        </li>
        <li>Self-capture is illegal in most versions of the rules around the world.</li>
        <li>Repetition of the arrangement of stones is illegal under various rulesets.
          For more detail see <i>local</i>, <i>positional</i> and <i>global</i> Ko rules.</li>
        <li>A game of Go is only finished when both players pass consecutively.
          This signifies that neither player has any meaningful moves left to play.</li>
        <li>Winning is determined by scoring the <i>area controlled</i> by the player's stones.
          Each stone or controlled empty spot is worth one point.
          An empty spot is considered controlled if fully enclosed by a player's stones (or edges of the board).
          Empty spots are <i>contested</i> if both player's stones partially surround them.
          Therefore, scoring the board can only be done once the game is finished.
          The player must attack and capture opponent stones placed inside the area it intends to claim.</li>
      </ol>
    </section>
    <section>
      <h2 id="FloodFill"><a href="#FloodFill">Flood Fill</a></h2>
      <p>Now that we feel comfortable <i>parsing</i> the text board we can look ahead to processing the board for more
        details.</p>
      <p>To reach our medium goal we need to "count liberties" and "score the game". Scoring the game further relies on
        identifying "enclosed empty spots" and which stone colour they "belong to".</p>
      <ol>
        <li><mark>Count Liberties</mark>
          <ul>
            <li>Follow a chain of same-colour stones.</li>
            <li>Count all the adjacent empty spots.</li>
          </ul>
        </li>
        <li><mark>Enclosed Empty Spots</mark>
          <ul>
            <li>Follow a chain of empty spots.</li>
            <li>Identify the adjacent stone colours.</li>
          </ul>
        </li>
      </ol>
      <p>Both of these abilities rely on an even smaller ability. We need to be able to follow "chains" of
        same-type pieces on the board. I know from experience that trying to do this task by "scanning" is possible
        but very time consuming. The efficient approach here is to use Flood Fill (aka DFS, Depth First Search)</p>
      <p>The scenario in <code>flood7x7.txt</code> challenges us to handle several issues.</p>
      <ul>
        <li>Follow the chain of stones through several branching points.</li>
        <li>Avoid an infinite loop following the circular path of stones.</li>
        <li>Avoid re-counting adjacent empty spots from multiple angles.</li>
      </ul>
      <pre><summary>flood7x7.txt</summary><code preload-txt="flood7x7.txt"></code></pre>
      <p>Let's count the number stones in the black chain and the number of liberties it's touching.
        We'll also show the number of <i>visits</i> at each location of the board during our Flood Fill.</p>
      <details>
        <summary>flood7x7.js</summary>
        <pre><code preload-javascript="flood7x7.js"></code></pre>
      </details>
      <script src="flood7x7.js" defer></script>
      <div data="flood7x7.txt" run="flood7x7">
        <button run>Run</button> <button time>Time</button> <mark hidden></mark>
        <pre><summary>output</summary><code output></code></pre>
      </div>
    </section>
    <section>
      <h2 id="LibertyCount"><a href="#LibertyCount">Liberty Count</a></h2>
      <p>At this point we have all of the pieces we need to calculate Liberties and Score.
        To get Liberty Counts for the whole board we only need to run Flood Fill for each stone.</p>
      <pre><summary>board7x7.txt</summary><code preload-txt="board7x7.txt"></code></pre>
      <details>
        <summary>liberty7x7.js</summary>
        <pre><code preload-javascript="liberty7x7.js"></code></pre>
      </details>
      <script src="liberty7x7.js" defer></script>
      <div data="board7x7.txt" run="liberty7x7">
        <button run>Run</button> <button time>Time</button> <mark hidden></mark>
        <pre><summary>output</summary><code output></code></pre>
      </div>
    </section>
    <section>
      <h2 id="Scoring"><a href="#Scoring">Scoring</a></h2>
      <p>The function <code>buildChains()</code> also doubles as a great way to count liberties.
        With that done the only ability we need code for now is Scoring the Game.
        Scoring is very similar to Counting Liberties with these differences:</p>
      <ul>
        <li>Follow empty spots instead of stones.</li>
        <li>Identify the <i>types</i> of adjacent stones instead of summing them up.</li>
      </ul>
      <div>
        <pre><summary>board7x7.txt</summary><code preload-txt="board7x7.txt"></code></pre>
      </div>
      <p>We'll need to scan the board for stones but not follow them,
        and follow empty spots as we find them.
        Let's only invoke DFS the first time we encounter each "chain" of empty spots.</p>
      <details>
        <summary>score7x7.js</summary>
        <pre><code preload-javascript="score7x7.js"></code></pre>
      </details>
      <script src="score7x7.js" defer></script>
      <div data="board7x7.txt" run="score7x7">
        <button run>Run</button> <button time>Time</button> <mark hidden></mark>
        <pre><summary>output</summary><code output></code></pre>
      </div>
    </section>
    <section>
      <h2 id="UnitTests"><a href="#UnitTests">Unit Tests</a></h2>
      <p>We have enough code now to solve all the unit tests in <code>liberty_score.txt</code>.
        But we still need to extract the tests from the text file and verify the outputs.</p>
      <details>
        <summary>liberty_score.txt</summary>
        <pre><code preload-txt="liberty_score.txt"></code></pre>
      </details>
      <p>Let's start by extracting the input/output boards:</p>
      <ul>
        <li><mark>Liberty Count</mark>
          <ul>
            <li>1 input board</li>
            <li>1 output board</li>
          </ul>
        </li>
        <li><mark>Enclosed Score</mark>
          <ul>
            <li>1 input board</li>
            <li>2 output boards</li>
            <li><code>key:val</code> pairs</li>
          </ul>
        </li>
      </ul>
      <details>
        <summary>extract_tests.js</summary>
        <pre><code preload-javascript="extract_tests.js"></code></pre>
      </details>
      <script src="extract_tests.js" defer></script>
      <div data="liberty_score.txt" run="extract_tests">
        <button run>Run</button> <button time>Time</button> <mark hidden></mark>
        <pre><summary>output</summary><code output></code></pre>
      </div>
      <p>We now have the full extraction of the Unit Tests.
        With tests in hand we can verify the correctness of our previous functions.</p>
      <details>
        <summary>test7x7.js</summary>
        <pre><code preload-javascript="test7x7.js"></code></pre>
      </details>
      <script src="test7x7.js" defer></script>
      <div data="liberty_score.txt" run="test7x7">
        <button run>Run</button> <button time>Time</button> <mark hidden></mark>
        <pre><summary>output</summary><code output></code></pre>
      </div>
    </section>
    <section>
      <h2 id="Rollouts"><a href="#Rollouts">Rollouts</a></h2>
      <p>Rollouts are the repeated action of adding stones to the board.
        For most of the Rollout the stone colour will strictly alternate.
        Near the end of the Rollout, one colour may need to pass (skip turn) before the other has run out of moves.
        Depending on captures, the colour that needs to pass may change hands several times.</p>
      <p>Key abilities needed for Rollouts:</p>
      <ul>
        <li><mark>Legal Moves</mark><br>
          Detecting which locations can be played on that will result in a valid board after the move.
        </li>
        <li><mark>Captures</mark><br>
          Detecting which chains need to be removed as a result of a stone being played.
        </li>
        <li><mark>Metadata</mark><br>
          Updating chains, ids and liberty counts.
          Preferably without recalculating the entire board.
        </li>
      </ul>
    </section>

  </main>
  <footer>
    <p>by <a href="https://lazymammal.github.io/">LazyMammal</a></p>
  </footer>
</body>

</html>